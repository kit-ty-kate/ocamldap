<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ldap_ooclient (ldap.Ldap_ooclient)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">ldap</a> &#x00BB; Ldap_ooclient</nav><h1>Module <code>Ldap_ooclient</code></h1><p>an object oriented ldap client interface</p><nav class="toc"><ul><li><a href="#basic-data-types">Basic Data Types</a></li><li><a href="#local-representation-of-ldap-objects">Local Representation of LDAP Objects</a></li><li><a href="#miscallaneous">Miscallaneous</a></li><li><a href="#communication-with-ldap_funclient">Communication with Ldap_funclient</a></li><li><a href="#interacting-with-ldap-servers">Interacting with LDAP Servers</a></li><li><a href="#iterators-over-streams-of-ldapentry-objects">Iterators Over Streams of ldapentry Objects</a></li><li><a href="#schema-aware-ldapentry-derivatives">Schema Aware ldapentry Derivatives</a><ul><li><a href="#general-schema-aware-entry">General Schema Aware Entry</a></li></ul></li><li><a href="#schema-aware-entry-for-account-managment">Schema Aware Entry for Account Managment</a></li></ul></nav></header><section><header><h2 id="basic-data-types"><a href="#basic-data-types" class="anchor"></a>Basic Data Types</h2></header><dl><dt class="spec type" id="type-op"><a href="#type-op" class="anchor"></a><code><span class="keyword">type</span> op</code><code> = string * <span>string list</span></code></dt><dd><p>the type of an operation, eg. <code>(&quot;cn&quot;, [&quot;foo&quot;;&quot;bar&quot;])</code></p></dd></dl><dl><dt class="spec type" id="type-op_lst"><a href="#type-op_lst" class="anchor"></a><code><span class="keyword">type</span> op_lst</code><code> = <span><a href="index.html#type-op">op</a> list</span></code></dt><dt class="spec type" id="type-referral_policy"><a href="#type-referral_policy" class="anchor"></a><code><span class="keyword">type</span> referral_policy</code> = <code>[ </code><table class="variant"><tr id="type-referral_policy.FOLLOW" class="anchored"><td class="def constructor"><a href="#type-referral_policy.FOLLOW" class="anchor"></a><code>| </code><code>`FOLLOW</code></td></tr><tr id="type-referral_policy.RETURN" class="anchored"><td class="def constructor"><a href="#type-referral_policy.RETURN" class="anchor"></a><code>| </code><code>`RETURN</code></td></tr></table><code> ]</code></dt><dd><p>The policy the client should take when it encounteres a referral. This is currently not used</p></dd></dl><dl><dt class="spec type" id="type-changetype"><a href="#type-changetype" class="anchor"></a><code><span class="keyword">type</span> changetype</code> = <code>[ </code><table class="variant"><tr id="type-changetype.ADD" class="anchored"><td class="def constructor"><a href="#type-changetype.ADD" class="anchor"></a><code>| </code><code>`ADD</code></td></tr><tr id="type-changetype.DELETE" class="anchored"><td class="def constructor"><a href="#type-changetype.DELETE" class="anchor"></a><code>| </code><code>`DELETE</code></td></tr><tr id="type-changetype.MODDN" class="anchored"><td class="def constructor"><a href="#type-changetype.MODDN" class="anchor"></a><code>| </code><code>`MODDN</code></td></tr><tr id="type-changetype.MODIFY" class="anchored"><td class="def constructor"><a href="#type-changetype.MODIFY" class="anchor"></a><code>| </code><code>`MODIFY</code></td></tr><tr id="type-changetype.MODRDN" class="anchored"><td class="def constructor"><a href="#type-changetype.MODRDN" class="anchor"></a><code>| </code><code>`MODRDN</code></td></tr></table><code> ]</code></dt><dd><p>The change type of an ldapentry. This controls some aspects of it's behavior</p></dd></dl></section><section><header><h2 id="local-representation-of-ldap-objects"><a href="#local-representation-of-ldap-objects" class="anchor"></a>Local Representation of LDAP Objects</h2></header><dl><dt class="spec class-type" id="class-type-ldapentry_t"><a href="#class-type-ldapentry_t" class="anchor"></a><code><span class="keyword">class</span> <span class="keyword">type</span>  <a href="class-type-ldapentry_t/index.html">ldapentry_t</a> = <span class="keyword">object</span> ... <span class="keyword">end</span></code></dt><dd><p>The base type of an ldap entry represented in memory.</p></dd></dl><dl><dt class="spec class" id="class-ldapentry"><a href="#class-ldapentry" class="anchor"></a><code><span class="keyword">class</span>  <a href="class-ldapentry/index.html">ldapentry</a> : <span class="keyword">object</span> ... <span class="keyword">end</span></code></dt><dd><p>this object represents a remote object within local memory. It records all local changes made to it (if it's changetype is set to `MODIFY), and can commit them to the server at a later time via <a href="class-ldapcon/index.html#method-update_entry"><code>Ldap_ooclient.ldapcon.update_entry</code></a>.</p></dd></dl></section><section><header><h2 id="miscallaneous"><a href="#miscallaneous" class="anchor"></a>Miscallaneous</h2></header><dl><dt class="spec value" id="val-format_entry"><a href="#val-format_entry" class="anchor"></a><code><span class="keyword">val</span> format_entry : &lt; attributes : <span>string list</span>; dn : string; get_value : string <span>&#45;&gt;</span> <span>string list</span>; .. &gt; <span>&#45;&gt;</span> unit</code></dt><dd><p>toplevel formatter for ldapentry, prints the whole entry with a nice structure. Each attribute is in the correct syntax to be copied and pasted into a modify operation.</p></dd></dl><dl><dt class="spec value" id="val-format_entries"><a href="#val-format_entries" class="anchor"></a><code><span class="keyword">val</span> format_entries : <span>&lt; attributes : <span>string list</span>; dn : string; get_value : string <span>&#45;&gt;</span> <span>string list</span>; .. &gt; list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>format lists of entries, in this case only print the dn</p></dd></dl><dl><dt class="spec type" id="type-changerec"><a href="#type-changerec" class="anchor"></a><code><span class="keyword">type</span> changerec</code> = <code>[ </code><table class="variant"><tr id="type-changerec.Modification" class="anchored"><td class="def constructor"><a href="#type-changerec.Modification" class="anchor"></a><code>| </code><code>`Modification <span class="keyword">of</span> string * <span><span>(<a href="../Ldap_types/index.html#type-modify_optype">Ldap_types.modify_optype</a> * string * <span>string list</span>)</span> list</span></code></td></tr><tr id="type-changerec.Addition" class="anchored"><td class="def constructor"><a href="#type-changerec.Addition" class="anchor"></a><code>| </code><code>`Addition <span class="keyword">of</span> <a href="class-ldapentry/index.html">ldapentry</a></code></td></tr><tr id="type-changerec.Delete" class="anchored"><td class="def constructor"><a href="#type-changerec.Delete" class="anchor"></a><code>| </code><code>`Delete <span class="keyword">of</span> string</code></td></tr><tr id="type-changerec.Modrdn" class="anchored"><td class="def constructor"><a href="#type-changerec.Modrdn" class="anchor"></a><code>| </code><code>`Modrdn <span class="keyword">of</span> string * int * string</code></td></tr></table><code> ]</code></dt><dd><p>The type of an ldap change record, used by extended LDIF</p></dd></dl></section><section><header><h2 id="communication-with-ldap_funclient"><a href="#communication-with-ldap_funclient" class="anchor"></a>Communication with Ldap_funclient</h2></header><aside><p>See <a href="../Ldap_funclient/index.html"><code>Ldap_funclient</code></a></p></aside><dl><dt class="spec value" id="val-to_entry"><a href="#val-to_entry" class="anchor"></a><code><span class="keyword">val</span> to_entry : <span>[&lt; <span>`Entry of <a href="../Ldap_types/index.html#type-search_result_entry">Ldap_types.search_result_entry</a></span> <span><span>| `Referral</span> of <span>string list</span></span> ]</span> <span>&#45;&gt;</span> <a href="class-ldapentry/index.html">ldapentry</a></code></dt><dd><p>given a search_result_entry as returned by ldap_funclient, produce an ldapentry containing either the entry, or the referral object</p></dd></dl><dl><dt class="spec value" id="val-of_entry"><a href="#val-of_entry" class="anchor"></a><code><span class="keyword">val</span> of_entry : <a href="class-ldapentry/index.html">ldapentry</a> <span>&#45;&gt;</span> <a href="../Ldap_types/index.html#type-search_result_entry">Ldap_types.search_result_entry</a></code></dt><dd><p>given an ldapentry as returned by ldapcon, or constructed manually, produce a search_result_entry suitable for ldap_funclient, or ldap_funserver.</p></dd></dl></section><section><header><h2 id="interacting-with-ldap-servers"><a href="#interacting-with-ldap-servers" class="anchor"></a>Interacting with LDAP Servers</h2></header><dl><dt class="spec class" id="class-ldapcon"><a href="#class-ldapcon" class="anchor"></a><code><span class="keyword">class</span>  <a href="class-ldapcon/index.html">ldapcon</a> : ?&#8288;connect_timeout:int <span>&#45;&gt;</span> ?&#8288;referral_policy:<span>[&gt; `RETURN ]</span> <span>&#45;&gt;</span> ?&#8288;version:int <span>&#45;&gt;</span> <span>string list</span> <span>&#45;&gt;</span> <span class="keyword">object</span> ... <span class="keyword">end</span></code></dt><dd><p>This class abstracts a connection to an LDAP server (or servers), an instance will be connected to the server you specify and can be used to perform operations on that server.</p></dd></dl></section><section><header><h2 id="iterators-over-streams-of-ldapentry-objects"><a href="#iterators-over-streams-of-ldapentry-objects" class="anchor"></a>Iterators Over Streams of ldapentry Objects</h2></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(<a href="class-ldapentry/index.html">ldapentry</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span>(<span>?&#8288;abandon:bool</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="class-ldapentry/index.html">ldapentry</a>)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>given a source of ldapentry objects (unit -&gt; ldapentry), such as the return value of ldapcon#search_a, apply f (first arg) to each entry See List.iter</p></dd></dl><dl><dt class="spec value" id="val-rev_map"><a href="#val-rev_map" class="anchor"></a><code><span class="keyword">val</span> rev_map : <span>(<a href="class-ldapentry/index.html">ldapentry</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span>?&#8288;abandon:bool</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="class-ldapentry/index.html">ldapentry</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>given a source of ldapentry objects (unit -&gt; ldapentry), such as the return value of ldapcon#search_a apply f (first arg) to each entry in reverse, and return a list containing the result of each application. See List.map</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<a href="class-ldapentry/index.html">ldapentry</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span>?&#8288;abandon:bool</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="class-ldapentry/index.html">ldapentry</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p>same as rev_map, but does it in order</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<a href="class-ldapentry/index.html">ldapentry</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span>?&#8288;abandon:bool</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="class-ldapentry/index.html">ldapentry</a>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>given a source of ldapentry objects (unit -&gt; ldapentry), such as the return value of ldapcon#search_a compute (f eN ... (f e2 (f e1 intial))) see List.fold_right.</p></dd></dl></section><section><header><h2 id="schema-aware-ldapentry-derivatives"><a href="#schema-aware-ldapentry-derivatives" class="anchor"></a>Schema Aware ldapentry Derivatives</h2></header><section><header><h3 id="general-schema-aware-entry"><a href="#general-schema-aware-entry" class="anchor"></a>General Schema Aware Entry</h3></header><aside><p><a href="class-scldapentry/index.html"><code>Ldap_ooclient.scldapentry</code></a>, A schema aware derivative of <a href="class-ldapentry/index.html"><code>Ldap_ooclient.ldapentry</code></a>. It contains an rfc2252 schema checker, and given the database schema, it can be used to garentee that operations performed in memory are valid against a standards compliant database. It has numerious uses, translation between two databases with different schemas an example of where it finds natural usage. For an example application</p><dl><dt>see <a href="http://tdir.sourceforge.net">http://tdir.sourceforge.net</a></dt><dd><p>tdir</p></dd></dl></aside><dl><dt class="spec module" id="module-OrdOid"><a href="#module-OrdOid" class="anchor"></a><code><span class="keyword">module</span> <a href="OrdOid/index.html">OrdOid</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>an ordered oid type, for placing oids in sets</p></dd></dl><dl><dt class="spec module" id="module-Setstr"><a href="#module-Setstr" class="anchor"></a><code><span class="keyword">module</span> <a href="Setstr/index.html">Setstr</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A set of Oids</p></dd></dl><dl><dt class="spec type" id="type-scflavor"><a href="#type-scflavor" class="anchor"></a><code><span class="keyword">type</span> scflavor</code><code> = </code><table class="variant"><tr id="type-scflavor.Optimistic" class="anchored"><td class="def constructor"><a href="#type-scflavor.Optimistic" class="anchor"></a><code>| </code><code><span class="constructor">Optimistic</span></code></td><td class="doc"><p>Add missing attributes to make the object consistant, or add objectclasses in order to make illegal attribues legal</p></td></tr><tr id="type-scflavor.Pessimistic" class="anchored"><td class="def constructor"><a href="#type-scflavor.Pessimistic" class="anchor"></a><code>| </code><code><span class="constructor">Pessimistic</span></code></td><td class="doc"><p>Delete objectclasses which must attributes which are missing, and delete illegal attributes.</p></td></tr></table></dt><dd><p>The type of schema checking to perform in <a href="class-scldapentry/index.html"><code>Ldap_ooclient.scldapentry</code></a>. Normally this is picked automatically, however it can be overridden in some cases.</p></dd></dl><dl><dt class="spec value" id="val-attrToOid"><a href="#val-attrToOid" class="anchor"></a><code><span class="keyword">val</span> attrToOid : <a href="../Ldap_schemaparser/index.html#type-schema">Ldap_schemaparser.schema</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/Lcstring/index.html#type-t">Ldap_schemaparser.Lcstring.t</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/Oid/index.html#type-t">Ldap_schemaparser.Oid.t</a></code></dt><dd><p>given a name of an attribute name (canonical or otherwise), return its oid</p><dl><dt>raises Invalid_attribute</dt><dd><p>If the attribute is not found in the schema.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-oidToAttr"><a href="#val-oidToAttr" class="anchor"></a><code><span class="keyword">val</span> oidToAttr : <a href="../Ldap_schemaparser/index.html#type-schema">Ldap_schemaparser.schema</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/Oid/index.html#type-t">Ldap_schemaparser.Oid.t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>given the oid of an attribute, return its canonical name</p><dl><dt>raises Invalid_attribute</dt><dd><p>If the attribute is not found in the schema.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-ocToOid"><a href="#val-ocToOid" class="anchor"></a><code><span class="keyword">val</span> ocToOid : <a href="../Ldap_schemaparser/index.html#type-schema">Ldap_schemaparser.schema</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/Lcstring/index.html#type-t">Ldap_schemaparser.Lcstring.t</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/Oid/index.html#type-t">Ldap_schemaparser.Oid.t</a></code></dt><dd><p>given a name of an objectclass (canonical or otherwise), return its oid.</p><dl><dt>raises Invalid_objectclass</dt><dd><p>If the objectclass is not found in the schema.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-oidToOc"><a href="#val-oidToOc" class="anchor"></a><code><span class="keyword">val</span> oidToOc : <a href="../Ldap_schemaparser/index.html#type-schema">Ldap_schemaparser.schema</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/Oid/index.html#type-t">Ldap_schemaparser.Oid.t</a> <span>&#45;&gt;</span> string</code></dt><dd><p>given the oid of an objectclass, return its canonical name</p><dl><dt>raises Invalid_objectclass</dt><dd><p>If the objectclass is not found in the schema.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-getOc"><a href="#val-getOc" class="anchor"></a><code><span class="keyword">val</span> getOc : <a href="../Ldap_schemaparser/index.html#type-schema">Ldap_schemaparser.schema</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/Lcstring/index.html#type-t">Ldap_schemaparser.Lcstring.t</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/index.html#type-objectclass">Ldap_schemaparser.objectclass</a></code></dt><dd><p>get an objectclass structure by one of its names (canonical or otherwise, however getting it by canonical name is currently much faster)</p><dl><dt>raises Invalid_objectclass</dt><dd><p>If the objectclass is not found in the schema.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-getAttr"><a href="#val-getAttr" class="anchor"></a><code><span class="keyword">val</span> getAttr : <a href="../Ldap_schemaparser/index.html#type-schema">Ldap_schemaparser.schema</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/Lcstring/index.html#type-t">Ldap_schemaparser.Lcstring.t</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/index.html#type-attribute">Ldap_schemaparser.attribute</a></code></dt><dd><p>get an attr structure by one of its names (canonical or otherwise, however getting it by canonical name is currently much faster)</p><dl><dt>raises Invalid_attribute</dt><dd><p>If the attribute is not found in the schema.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-equateAttrs"><a href="#val-equateAttrs" class="anchor"></a><code><span class="keyword">val</span> equateAttrs : <a href="../Ldap_schemaparser/index.html#type-schema">Ldap_schemaparser.schema</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/Lcstring/index.html#type-t">Ldap_schemaparser.Lcstring.t</a> <span>&#45;&gt;</span> <a href="../Ldap_schemaparser/Lcstring/index.html#type-t">Ldap_schemaparser.Lcstring.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>equate attributes by oid. This allows non canonical names to be handled correctly, for example &quot;uid&quot; and &quot;userID&quot; are actually the same attribute.</p><dl><dt>raises Invalid_attribute</dt><dd><p>If either attribute is not found in the schema.</p></dd></dl></dd></dl><dl><dt class="spec exception" id="exception-Invalid_objectclass"><a href="#exception-Invalid_objectclass" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Invalid_objectclass</span> <span class="keyword">of</span> string</code></dt><dt class="spec exception" id="exception-Invalid_attribute"><a href="#exception-Invalid_attribute" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Invalid_attribute</span> <span class="keyword">of</span> string</code></dt><dt class="spec exception" id="exception-Single_value"><a href="#exception-Single_value" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Single_value</span> <span class="keyword">of</span> string</code></dt><dt class="spec exception" id="exception-Objectclass_is_required"><a href="#exception-Objectclass_is_required" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Objectclass_is_required</span></code></dt></dl><div class="spec class" id="class-scldapentry"><a href="#class-scldapentry" class="anchor"></a><code><span class="keyword">class</span>  <a href="class-scldapentry/index.html">scldapentry</a> : <a href="../Ldap_schemaparser/index.html#type-schema">Ldap_schemaparser.schema</a> <span>&#45;&gt;</span> <span class="keyword">object</span> ... <span class="keyword">end</span></code></div></section></section><section><header><h2 id="schema-aware-entry-for-account-managment"><a href="#schema-aware-entry-for-account-managment" class="anchor"></a>Schema Aware Entry for Account Managment</h2></header><aside><p>A derivative of <a href="class-scldapentry/index.html"><code>Ldap_ooclient.scldapentry</code></a> which includes abstractions for managing user accounts in the directory. This class is experimantal, and may be drastically changed in the next version. As with all experimental code, use with caution. A few of its features.</p><ul><li>Loosely dependant attributes: Many attributes are derived from others via a function. ldapaccount allows you to codify that relationship by providing an attribute generator (<a href="index.html#type-generator"><code>Ldap_ooclient.generator</code></a>) for the attribute, which will be used to derive it's value except in the case that it is specified explicitly</li><li>Attribute and Generator Grouping: via the service abstraction. Allows you to group attributes together with generators and default values in interesting ways. You can then assign the whole grouping a name, and refer to it by that name. See <a href="index.html#type-service"><code>Ldap_ooclient.service</code></a></li><li>Difference Based: Service operations are difference based, all applications of service operations compute the delta between the current object, and what the service requires. The minumum set of changes necessary to satisfy the service are applied to the object.</li><li>Idempotentcy: As a result of being difference based, Service operations are itempotent. For example, adding a service twice has no effect on the object. It will not queue changes for modification to the directory, and it will not change the object in memory. Deleting a service twice has no effect...etc</li></ul></aside><dl><dt class="spec type" id="type-generator"><a href="#type-generator" class="anchor"></a><code><span class="keyword">type</span> generator</code><code> = </code><code>{</code><table class="record"><tr id="type-generator.gen_name" class="anchored"><td class="def field"><a href="#type-generator.gen_name" class="anchor"></a><code>gen_name : string;</code></td><td class="doc"><p>The name of the generator, this should also be its key in the hashtbl</p></td></tr><tr id="type-generator.required" class="anchored"><td class="def field"><a href="#type-generator.required" class="anchor"></a><code>required : <span>string list</span>;</code></td><td class="doc"><p>A list of names of attributes which are required by this generator. The names need not be canonical.</p></td></tr><tr id="type-generator.genfun" class="anchored"><td class="def field"><a href="#type-generator.genfun" class="anchor"></a><code>genfun : <a href="class-type-ldapentry_t/index.html">ldapentry_t</a> <span>&#45;&gt;</span> <span>string list</span>;</code></td><td class="doc"><p>A function which returns a list of values for the attribute, given the entire object.</p></td></tr></table><code>}</code></dt><dd><p>The structure of a generator</p></dd></dl><dl><dt class="spec type" id="type-service"><a href="#type-service" class="anchor"></a><code><span class="keyword">type</span> service</code><code> = </code><code>{</code><table class="record"><tr id="type-service.svc_name" class="anchored"><td class="def field"><a href="#type-service.svc_name" class="anchor"></a><code>svc_name : string;</code></td><td class="doc"><p>The name of the service, should also be its key in the hashtbl.</p></td></tr><tr id="type-service.static_attrs" class="anchored"><td class="def field"><a href="#type-service.static_attrs" class="anchor"></a><code>static_attrs : <span><span>(string * <span>string list</span>)</span> list</span>;</code></td><td class="doc"><p>A list of attributes and values which must be present for the service to be satisfied.</p></td></tr><tr id="type-service.generate_attrs" class="anchored"><td class="def field"><a href="#type-service.generate_attrs" class="anchor"></a><code>generate_attrs : <span>string list</span>;</code></td><td class="doc"><p>A list of attributes to generate.</p></td></tr><tr id="type-service.depends" class="anchored"><td class="def field"><a href="#type-service.depends" class="anchor"></a><code>depends : <span>string list</span>;</code></td><td class="doc"><p>A list of services on which this service depends.</p></td></tr></table><code>}</code></dt><dd><p>The structure of a service</p></dd></dl><dl><dt class="spec type" id="type-generation_error"><a href="#type-generation_error" class="anchor"></a><code><span class="keyword">type</span> generation_error</code><code> = </code><table class="variant"><tr id="type-generation_error.Missing_required" class="anchored"><td class="def constructor"><a href="#type-generation_error.Missing_required" class="anchor"></a><code>| </code><code><span class="constructor">Missing_required</span> <span class="keyword">of</span> <span>string list</span></code></td></tr><tr id="type-generation_error.Generator_error" class="anchored"><td class="def constructor"><a href="#type-generation_error.Generator_error" class="anchor"></a><code>| </code><code><span class="constructor">Generator_error</span> <span class="keyword">of</span> string</code></td></tr></table></dt><dd><p>The type of error raised by attribute generators</p></dd></dl><dl><dt class="spec exception" id="exception-No_generator"><a href="#exception-No_generator" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">No_generator</span> <span class="keyword">of</span> string</code></dt><dd><p>You've asked it to generate an attribute (in a service) which doesn't have a generator</p></dd></dl><dl><dt class="spec exception" id="exception-Generation_failed"><a href="#exception-Generation_failed" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Generation_failed</span> <span class="keyword">of</span> <a href="index.html#type-generation_error">generation_error</a></code></dt><dd><p>Generator has failed because of some kind of error</p></dd></dl><dl><dt class="spec exception" id="exception-No_service"><a href="#exception-No_service" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">No_service</span> <span class="keyword">of</span> string</code></dt><dd><p>The service you're talking about doesn't exist</p></dd></dl><dl><dt class="spec exception" id="exception-Service_dep_unsatisfiable"><a href="#exception-Service_dep_unsatisfiable" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Service_dep_unsatisfiable</span> <span class="keyword">of</span> string</code></dt><dd><p>A service which the one you tried to add depends on doesn't exists</p></dd></dl><dl><dt class="spec exception" id="exception-Generator_dep_unsatisfiable"><a href="#exception-Generator_dep_unsatisfiable" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Generator_dep_unsatisfiable</span> <span class="keyword">of</span> string * string</code></dt><dd><p>Your generator depends on an attribute which isn't in the schema</p></dd></dl><dl><dt class="spec exception" id="exception-Cannot_sort_dependancies"><a href="#exception-Cannot_sort_dependancies" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Cannot_sort_dependancies</span> <span class="keyword">of</span> <span>string list</span></code></dt><dd><p>You have detached cycles in your generator dependancy lists</p></dd></dl><div class="spec class" id="class-ldapaccount"><a href="#class-ldapaccount" class="anchor"></a><code><span class="keyword">class</span>  <a href="class-ldapaccount/index.html">ldapaccount</a> : <a href="../Ldap_schemaparser/index.html#type-schema">Ldap_schemaparser.schema</a> <span>&#45;&gt;</span> <span><span>(string, <a href="index.html#type-generator">generator</a>)</span> Stdlib.Hashtbl.t</span> <span>&#45;&gt;</span> <span><span>(string, <a href="index.html#type-service">service</a>)</span> Stdlib.Hashtbl.t</span> <span>&#45;&gt;</span> <span class="keyword">object</span> ... <span class="keyword">end</span></code></div></section></div></body></html>